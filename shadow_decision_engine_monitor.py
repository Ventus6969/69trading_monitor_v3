"""
ÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÈÇèËºØ - Áõ£Êéß‰∏ªÊ©üÁâàÊú¨
‰øÆÊîπÂ∞éÂÖ•Ë∑ØÂæëÔºåÈÅ©ÈÖçÁõ£Êéß‰∏ªÊ©üÁí∞Â¢É
=============================================================================
"""
import logging
import time
from datetime import datetime
from typing import Dict, Any, Optional, Tuple

# Ë®≠ÁΩÆlogger
logger = logging.getLogger(__name__)

class ShadowModeDecisionEngine:
    """ÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÂºïÊìé - Áõ£Êéß‰∏ªÊ©üÁâàÊú¨"""
    
    def __init__(self):
        self.min_data_for_ml = 50  # ÊúÄÂ∞ëÊï∏ÊìöÈáèÊâçÂïüÁî®MLÊ®°Âûã
        self.decision_threshold = 0.7  # Ê±∫Á≠ñÈñæÂÄº
        self.confidence_threshold = 0.6  # ‰ø°ÂøÉÂ∫¶ÈñæÂÄº
        
        # Âü∫ÊñºÂ∑≤Áü•‰∫§ÊòìÁöÑÊ¥ûÂØüÂª∫Á´ãÂàùÂßãË¶èÂâá
        self.strategy_rules = self._initialize_strategy_rules()
        
        logger.info("ÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÂºïÊìéÂ∑≤ÂàùÂßãÂåñ (Áõ£Êéß‰∏ªÊ©üÁâàÊú¨)")
    
    def _initialize_strategy_rules(self) -> Dict[str, Dict]:
        """ÂàùÂßãÂåñÁ≠ñÁï•Ë¶èÂâá"""
        return {
            # È´òÈ¢®Èö™ÁµÑÂêà
            'high_risk_combinations': [
                {'signal_type': 'consolidation_buy', 'opposite': 2, 'risk_level': 'HIGH'},
                {'signal_type': 'reversal_buy', 'opposite': 2, 'risk_level': 'HIGH'},
            ],
            
            # È´òÂìÅË≥™ÁµÑÂêà
            'high_quality_combinations': [
                {'signal_type': 'breakdown_sell', 'opposite': 0, 'risk_level': 'LOW'},
            ],
            
            # Á≠ñÁï•ÂÅèÂ•Ω
            'strategy_preferences': {
                'breakout_buy': {'default_confidence': 0.5, 'note': 'Á™ÅÁ†¥Á≠ñÁï•Ôºå‰∏≠Á≠âÈ¢®Èö™'},
                'consolidation_buy': {'default_confidence': 0.3, 'note': 'Êï¥ÁêÜÁ≠ñÁï•ÔºåËºÉÈ´òÈ¢®Èö™'},
                'reversal_buy': {'default_confidence': 0.4, 'note': 'ÂèçËΩâÁ≠ñÁï•Ôºå‰∏≠Á≠âÈ¢®Èö™'},
                'bounce_buy': {'default_confidence': 0.5, 'note': 'ÂèçÂΩàÁ≠ñÁï•Ôºå‰∏≠Á≠âÈ¢®Èö™'},
                'trend_sell': {'default_confidence': 0.6, 'note': 'Ë∂®Âã¢Á≠ñÁï•ÔºåËºÉ‰ΩéÈ¢®Èö™'},
                'breakdown_sell': {'default_confidence': 0.7, 'note': 'Á†¥Â∫ïÁ≠ñÁï•Ôºå‰ΩéÈ¢®Èö™'},
                'high_sell': {'default_confidence': 0.5, 'note': 'È´ò‰ΩçÁ≠ñÁï•Ôºå‰∏≠Á≠âÈ¢®Èö™'},
                'reversal_sell': {'default_confidence': 0.4, 'note': 'ÂèçËΩâÁ≠ñÁï•Ôºå‰∏≠Á≠âÈ¢®Èö™'}
            }
        }
    
    def make_shadow_decision(self, session_id: str, signal_id: int, 
                           features: Dict[str, Any], signal_data: Dict[str, Any]) -> Dict[str, Any]:
        """ÁîüÊàêÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÂª∫Ë≠∞"""
        try:
            logger.info(f"ÈñãÂßãÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÂàÜÊûê - signal_id: {signal_id}")
            
            # Ê™¢Êü•ÊòØÂê¶ÊúâË∂≥Â§†Êï∏Êìö‰ΩøÁî®MLÊ®°Âûã
            if self._should_use_ml_model():
                decision_result = self._ml_based_decision(features, signal_data)
                decision_result['decision_method'] = 'ML_MODEL'
            else:
                decision_result = self._rule_based_decision(features, signal_data)
                decision_result['decision_method'] = 'RULE_BASED'
            
            # Ë®òÈåÑÊ±∫Á≠ñÁµêÊûú
            self._record_shadow_decision(session_id, signal_id, decision_result, features, signal_data)
            
            # Ë©≥Á¥∞Êó•Ë™åË®òÈåÑ
            self._log_decision_details(signal_id, decision_result, signal_data)
            
            return decision_result
            
        except Exception as e:
            logger.error(f"ÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÊôÇÂá∫ÈåØ: {str(e)}")
            return self._get_fallback_decision(signal_data, str(e))
    
    def _should_use_ml_model(self) -> bool:
        """Ê™¢Êü•ÊòØÂê¶ÊáâË©≤‰ΩøÁî®MLÊ®°Âûã"""
        try:
            # Áõ£Êéß‰∏ªÊ©üÁâàÊú¨ÔºöÊö´ÊôÇÁ∏ΩÊòØ‰ΩøÁî®Ë¶èÂâáÊ±∫Á≠ñ
            return False
        except Exception as e:
            logger.warning(f"Ê™¢Êü•MLÊ®°ÂûãÂèØÁî®ÊÄßÊôÇÂá∫ÈåØ: {str(e)}ÔºåÂõûÈÄÄÂà∞Ë¶èÂâáÊ±∫Á≠ñ")
            return False
    
    def _rule_based_decision(self, features: Dict[str, Any], signal_data: Dict[str, Any]) -> Dict[str, Any]:
        """Âü∫ÊñºË¶èÂâáÁöÑÊ±∫Á≠ñÈÇèËºØ"""
        signal_type = signal_data.get('signal_type')
        opposite = signal_data.get('opposite', 0)
        symbol = signal_data.get('symbol', '')
        
        # 1. Ê™¢Êü•ÊòØÂê¶ÁÇ∫Â∑≤Áü•È´òÈ¢®Èö™ÁµÑÂêà
        for high_risk in self.strategy_rules['high_risk_combinations']:
            if (signal_type == high_risk['signal_type'] and 
                opposite == high_risk['opposite']):
                return {
                    'recommendation': 'SKIP',
                    'confidence': 0.3,
                    'reason': f'Â∑≤Áü•È´òÈ¢®Èö™ÁµÑÂêà: {signal_type} + opposite={opposite}',
                    'risk_level': 'HIGH',
                    'execution_probability': 0.3,
                    'trading_probability': 0.3,
                    'suggested_price_adjustment': 0.0
                }
        
        # 2. Ê™¢Êü•ÊòØÂê¶ÁÇ∫Â∑≤Áü•È´òÂìÅË≥™ÁµÑÂêà
        for high_quality in self.strategy_rules['high_quality_combinations']:
            if (signal_type == high_quality['signal_type'] and 
                opposite == high_quality['opposite']):
                return {
                    'recommendation': 'EXECUTE',
                    'confidence': 0.8,
                    'reason': f'Â∑≤Áü•È´òÂìÅË≥™ÁµÑÂêà: {signal_type} + opposite={opposite}',
                    'risk_level': 'LOW',
                    'execution_probability': 0.8,
                    'trading_probability': 0.8,
                    'suggested_price_adjustment': 0.0
                }
        
        # 3. Âü∫ÊñºÁ≠ñÁï•ÂÅèÂ•ΩË©ï‰º∞
        strategy_pref = self.strategy_rules['strategy_preferences'].get(signal_type, {})
        base_confidence = strategy_pref.get('default_confidence', 0.5)
        
        # 4. Âü∫ÊñºoppositeÂÄºË™øÊï¥‰ø°ÂøÉÂ∫¶
        opposite_adjustment = self._calculate_opposite_adjustment(opposite)
        final_confidence = max(0.1, min(0.9, base_confidence + opposite_adjustment))
        
        # 5. ÁîüÊàêÊ±∫Á≠ñ
        recommendation = 'EXECUTE' if final_confidence >= self.confidence_threshold else 'SKIP'
        
        return {
            'recommendation': recommendation,
            'confidence': final_confidence,
            'reason': f"Á≠ñÁï•Ë©ï‰º∞: {strategy_pref.get('note', 'Êú™Áü•Á≠ñÁï•')}, oppositeË™øÊï¥: {opposite_adjustment:+.2f}",
            'risk_level': 'MEDIUM',
            'execution_probability': final_confidence,
            'trading_probability': final_confidence,
            'suggested_price_adjustment': 0.0
        }
    
    def _calculate_opposite_adjustment(self, opposite: int) -> float:
        """Âü∫ÊñºoppositeÂÄºË®àÁÆó‰ø°ÂøÉÂ∫¶Ë™øÊï¥"""
        if opposite == 0:
            return 0.1  # Áï∂ÂâçÊî∂Áõ§ÂÉπÔºåÁõ∏Â∞çËºÉÂ•Ω
        elif opposite == 1:
            return 0.0  # ÂâçÊ†πÊî∂Áõ§ÂÉπÔºå‰∏≠ÊÄß
        elif opposite == 2:
            return -0.1  # ÂâçÊ†πÈñãÁõ§ÂÉπÔºåÂ∑≤Áü•ÂïèÈ°åËºÉÂ§ö
        else:
            return -0.1  # Êú™Áü•ÂÄºÔºå‰øùÂÆàËôïÁêÜ
    
    def _ml_based_decision(self, features: Dict[str, Any], signal_data: Dict[str, Any]) -> Dict[str, Any]:
        """Âü∫ÊñºMLÊ®°ÂûãÁöÑÊ±∫Á≠ñÈÇèËºØ"""
        logger.info("MLÊ®°ÂûãÂäüËÉΩÈñãÁôº‰∏≠ÔºåÊö´ÊôÇ‰ΩøÁî®Â¢ûÂº∑Ë¶èÂâáÈÇèËºØ")
        
        # Êö´ÊôÇË™øÁî®Ë¶èÂâáÊ±∫Á≠ñÔºå‰ΩÜÊèêÈ´ò‰ø°ÂøÉÂ∫¶
        rule_result = self._rule_based_decision(features, signal_data)
        
        # MLÁâàÊú¨ÁöÑÂ¢ûÂº∑
        rule_result['confidence'] = min(1.0, rule_result['confidence'] + 0.1)
        rule_result['reason'] += ' (MLÂ¢ûÂº∑Áâà)'
        
        return rule_result
    
    def _record_shadow_decision(self, session_id: str, signal_id: int, 
                               decision_result: Dict[str, Any], features: Dict[str, Any], 
                               signal_data: Dict[str, Any]) -> bool:
        """Ë®òÈåÑÂΩ±Â≠êÊ±∫Á≠ñÂà∞Ë≥áÊñôÂ∫´"""
        try:
            # Áõ£Êéß‰∏ªÊ©üÁâàÊú¨ÔºöÂèØ‰ª•Ë®òÈåÑÂà∞Êú¨Âú∞Êï∏ÊìöÂ∫´
            # ‰ΩÜÊö´ÊôÇ‰∏çÂØ¶ÁèæÔºåÈÅøÂÖçÂæ™Áí∞‰æùË≥¥
            logger.info(f"ÂΩ±Â≠êÊ±∫Á≠ñË®òÈåÑ - signal_id: {signal_id}, Âª∫Ë≠∞: {decision_result.get('recommendation')}")
            return True
            
        except Exception as e:
            logger.error(f"Ë®òÈåÑÂΩ±Â≠êÊ±∫Á≠ñÊôÇÂá∫ÈåØ: {str(e)}")
            return False
    
    def _log_decision_details(self, signal_id: int, decision_result: Dict[str, Any], 
                            signal_data: Dict[str, Any]):
        """Ë©≥Á¥∞Ë®òÈåÑÊ±∫Á≠ñÊó•Ë™å"""
        signal_type = signal_data.get('signal_type')
        opposite = signal_data.get('opposite')
        symbol = signal_data.get('symbol')
        
        logger.info(f"ü§ñ ÂΩ±Â≠êÊ®°ÂºèÊ±∫Á≠ñÂÆåÊàê:")
        logger.info(f"   ‰ø°Ëôü: {signal_type} | opposite: {opposite} | ‰∫§ÊòìÂ∞ç: {symbol}")
        logger.info(f"   Âª∫Ë≠∞: {decision_result.get('recommendation')}")
        logger.info(f"   ‰ø°ÂøÉÂ∫¶: {decision_result.get('confidence', 0):.1%}")
        logger.info(f"   Âü∑Ë°åÊ¶ÇÁéá: {decision_result.get('execution_probability', 0):.1%}")
        logger.info(f"   ÁêÜÁî±: {decision_result.get('reason')}")
        logger.info(f"   ÊñπÊ≥ï: {decision_result.get('decision_method')}")
    
    def _get_fallback_decision(self, signal_data: Dict[str, Any], error_msg: str) -> Dict[str, Any]:
        """ÈåØË™§ÊôÇÁöÑÂõûÈÄÄÊ±∫Á≠ñ"""
        return {
            'recommendation': 'EXECUTE',
            'confidence': 0.5,
            'reason': f'ÂΩ±Â≠êÊ®°ÂºèÈåØË™§ÂõûÈÄÄ: {error_msg}',
            'risk_level': 'UNKNOWN',
            'execution_probability': 0.5,
            'trading_probability': 0.5,
            'suggested_price_adjustment': 0.0,
            'decision_method': 'FALLBACK'
        }
    
    def get_shadow_statistics(self) -> Dict[str, Any]:
        """Áç≤ÂèñÂΩ±Â≠êÊ®°ÂºèÁµ±Ë®à"""
        try:
            return {
                'total_decisions': 0,
                'ml_ready': False,
                'data_progress': f"0/{self.min_data_for_ml}",
                'current_mode': 'RULE_BASED'
            }
            
        except Exception as e:
            logger.error(f"Áç≤ÂèñÂΩ±Â≠êÊ®°ÂºèÁµ±Ë®àÊôÇÂá∫ÈåØ: {str(e)}")
            return {'error': str(e)}

# ÂâµÂª∫ÂÖ®Â±ÄÂΩ±Â≠êÊ±∫Á≠ñÂºïÊìéÂØ¶‰æã
shadow_decision_engine = ShadowModeDecisionEngine()
